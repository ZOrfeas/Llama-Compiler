let main d (b : array of bool) c = not (let foo (bar : foo) (bar : array of array [*,*] of d -> (char) -> (bool) -> d ref) main : e = ()
and foo f g main b = 14
and g = 9 in (delete 41))
and d (a : bool) foo b foo = begin not (f[match () with
  (-29) -> false
end
,(() <> ())]) end
and e g c = (new char mod (let rec mutable e[9,false]
and d b = () in 0.0))
and g = if '\n' then (while 42.0 do 3 done) else begin () end
and g = delete (let a main main : f = true
and a c = false
and d bar : bool = 38
and g d bar : unit ref = false
and e (d : unit) e = "Route66" in (while false do '7' done))

let main = match (true mod "foo") with
  (-.0.0) -> b['\n','7']
| (+.0.0) -> while "Route66" do 33 done
end

and f : array [*,*] of array of char -> unit ref ref ref -> main = Tree ((new unit))

type main = Cons | C
 and f = B | A | B of b bool (unit)
 and foo = D

